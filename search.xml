<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Linux中查找所有文件中含有特定字符串的脚本</title>
    <url>/2023/05/25/linuxzhong-cha-zhao-suo-you-wen-jian-zhong-han-you-te-ding-zi-fu-chuan-de-jiao-ben/</url>
    <content><![CDATA[<p>查找所有文件，命令：<code>sudo ./find.sh [路径]</code><br>他会查找该目录所有文件，并将匹配的文件和内容输出</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">maple</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"></span></span><br><span class="line">function scan &#123;</span><br><span class="line">        if [ -f $1 ];then</span><br><span class="line">                echo &#x27;file&#x27; $1</span><br><span class="line">                cat $1 | grep &#x27;[0-9]\+&#x27; # 这里匹配的是正则表达式，根据需要自行修改</span><br><span class="line">        elif [ -d $1 ];then</span><br><span class="line">                for f in `ls -a $1`;do # la -a 会匹配所有文件，所有将 . 和 .. 排除 </span><br><span class="line">                        if [ $f = &#x27;.&#x27; ] || [ $f = &#x27;..&#x27; ];then</span><br><span class="line">                                continue</span><br><span class="line">                        else</span><br><span class="line">                                scan $1/$f # 递归扫描</span><br><span class="line">                        fi</span><br><span class="line">                done</span><br><span class="line">        fi</span><br><span class="line">&#125;</span><br><span class="line">echo &#x27;start scan&#x27;</span><br><span class="line">scan $1</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>script</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>gateway的使用记录</title>
    <url>/2023/05/07/gatewayde-shi-yong-ji-lu/</url>
    <content><![CDATA[<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><h3 id="添加依赖"><a href="#添加依赖" class="headerlink" title="添加依赖"></a>添加依赖</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-gateway<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 新版gateway需要加上lb依赖 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-loadbalancer<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="过滤器"><a href="#过滤器" class="headerlink" title="过滤器"></a>过滤器</h3><ol>
<li>gateway可以添加过滤器，以实现修改请求头，鉴权等功能<code>(实现GlobalFilter接口)</code>，并加入<code>@Component</code>注解,<code>@Order</code>注解设置优先级  </li>
<li>请求路由后 当前路由的过滤器 -&gt; DefaultFilter -&gt; GobalFilter 合并到一个过滤器链,排序后依次执行  </li>
<li>当过滤器的值一样时,会按照defaultFilter -&gt; 路由过滤器 -&gt; GobalFilter的顺序执行</li>
</ol>
<h3 id="跨域"><a href="#跨域" class="headerlink" title="跨域"></a>跨域</h3><p>开卷考试</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">globalcors:</span> <span class="comment"># 全局的跨域处理</span></span><br><span class="line">        <span class="attr">add-to-simple-url-handler-mapping:</span> <span class="literal">true</span> <span class="comment"># 解决options请求被拦截问题</span></span><br><span class="line">        <span class="attr">corsConfigurations:</span></span><br><span class="line">          <span class="string">&#x27;[/**]&#x27;</span><span class="string">:</span></span><br><span class="line">            <span class="attr">allowedOrigins:</span> <span class="comment"># 允许哪些网站的跨域请求</span></span><br><span class="line">              <span class="bullet">-</span> <span class="string">&quot;http://localhost:8090&quot;</span></span><br><span class="line">              <span class="bullet">-</span> <span class="string">&quot;http://www.leyou.com&quot;</span></span><br><span class="line">            <span class="attr">allowedMethods:</span> <span class="comment"># 允许的跨域ajax的请求方式</span></span><br><span class="line">              <span class="bullet">-</span> <span class="string">&quot;GET&quot;</span></span><br><span class="line">              <span class="bullet">-</span> <span class="string">&quot;POST&quot;</span></span><br><span class="line">              <span class="bullet">-</span> <span class="string">&quot;DELETE&quot;</span></span><br><span class="line">              <span class="bullet">-</span> <span class="string">&quot;PUT&quot;</span></span><br><span class="line">              <span class="bullet">-</span> <span class="string">&quot;OPTIONS&quot;</span></span><br><span class="line">            <span class="attr">allowedHeaders:</span> <span class="string">&quot;*&quot;</span> <span class="comment"># 允许在请求中携带的头信息</span></span><br><span class="line">            <span class="attr">allowCredentials:</span> <span class="literal">true</span> <span class="comment"># 是否允许携带cookie</span></span><br><span class="line">            <span class="attr">maxAge:</span> <span class="number">360000</span> <span class="comment"># 这次跨域检测的有效期</span></span><br></pre></td></tr></table></figure>
<h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p>Gateway不是Nginx，他只是分流，没有做代理!!</p>
]]></content>
      <categories>
        <category>spring cloud</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>gateway</tag>
      </tags>
  </entry>
  <entry>
    <title>git常用命令</title>
    <url>/2023/05/26/gitchang-yong-ming-ling/</url>
    <content><![CDATA[<h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git add [文件/文件夹]</span><br></pre></td></tr></table></figure>
<p>开始追踪文件</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git commit [-a|-m &#123;消息&#125;]</span><br></pre></td></tr></table></figure>
<p>提交更改</p>
<ul>
<li><p><code>-a</code>：为已追踪文件运行<code>git add</code></p>
</li>
<li><p><code>-m</code>：添加本次提交消息  </p>
</li>
</ul>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">```sh</span><br><span class="line">git <span class="built_in">rm</span> [文件/文件夹]</span><br></pre></td></tr></table></figure>
<p>  停止追踪并删除该文件</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">  </span><br><span class="line">```sh</span><br><span class="line">git <span class="built_in">log</span> [--oneline|--decorate|--max-count]</span><br></pre></td></tr></table></figure>
<p>显示git日志</p>
<ul>
<li><p><code>--oneline</code>：减少显示的哈希值长度</p>
</li>
<li><p><code>--decorate</code>：装饰，打印出显示的任何提交的引用名称。如果指定了<em>short</em> ，则不会打印ref 名称前缀<em>refs/heads/</em>、<em>refs/tags/</em>和 <em>refs/remotes/ 。</em>如果指定了<em>full</em>，将打印完整的 ref 名称（包括前缀）。如果指定了<em>auto</em>，那么如果输出到终端，则显示 ref 名称，就好像给出了<em>short一样，否则不显示任何 ref 名称。</em>该选项<code>--decorate</code>是<code>--decorate=short</code>. 如果已配置，则默认为配置值<code>log.decorate</code>，否则为<code>auto</code></p>
</li>
<li><p><code>--max-count</code>：显示最多多少行，还可以选择限制条件一起限制</p>
</li>
</ul>
<h2 id="分支相关"><a href="#分支相关" class="headerlink" title="分支相关"></a>分支相关</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git branch [新分支名称，如不填写，则可以查看所有分支]</span><br></pre></td></tr></table></figure>
<p>迁出分支</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git checkout [-b|-d] [分支名称]</span><br></pre></td></tr></table></figure>
<p>切换分支</p>
<ul>
<li><code>-b</code>：相当于<code>git branch [分支名称]</code>，直接创建并切换到新分支</li>
<li><code>-d</code>：删除分支</li>
</ul>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git merge [分支名]</span><br></pre></td></tr></table></figure>
<p>合并分支</p>
<h2 id="Git工具"><a href="#Git工具" class="headerlink" title="Git工具"></a>Git工具</h2><h3 id="储藏与清理"><a href="#储藏与清理" class="headerlink" title="储藏与清理"></a>储藏与清理</h3><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git stash</span><br></pre></td></tr></table></figure>
<p>暂存进度，将其放入栈内</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git stash list</span><br></pre></td></tr></table></figure>
<p>查看存储的东西</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git stash apply [还原的储藏名称，不填则还原栈顶的储藏]</span><br></pre></td></tr></table></figure>
<p>还原储藏，可指定储藏名称</p>
]]></content>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2023/04/27/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>jackson的简单使用</title>
    <url>/2023/05/06/jacksonde-jian-dan-shi-yong/</url>
    <content><![CDATA[<p>jackson是一款安全的json处理框架<br>大部分都依靠<code>ObjectMapper</code>这个工具类据处理json对象<br>jackson里的json对象分三种<code>JsonNode</code>,<code>ObjectNode</code>和<code>ArrayNode</code><br><code>JsonNode</code>不可更改,<code>ObjectNode</code>是可变的,<code>ArraryNode</code>是列表<br>输出的缩进格式可以更改</p>
]]></content>
      <tags>
        <tag>java</tag>
        <tag>jackson</tag>
      </tags>
  </entry>
  <entry>
    <title>nacos使用记录</title>
    <url>/2023/05/06/nacosshi-yong-ji-lu/</url>
    <content><![CDATA[<h2 id="nacos分级存储模型"><a href="#nacos分级存储模型" class="headerlink" title="nacos分级存储模型"></a>nacos分级存储模型</h2><ol>
<li>服务，如userservice</li>
<li>集群，如杭州、上海</li>
<li>实例</li>
</ol>
<h2 id="服务发现和服务注册"><a href="#服务发现和服务注册" class="headerlink" title="服务发现和服务注册"></a>服务发现和服务注册</h2><p>添加依赖  </p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-discovery<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>配置，与eureka类似，也需要配置服务器，还可以配置集群<code>(默认为同一集群)</code>名称</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">server-addr:</span> <span class="string">localhost:8848</span></span><br><span class="line">      <span class="attr">discovery:</span></span><br><span class="line">        <span class="attr">cluster-name:</span> <span class="string">DEFAULT</span> <span class="comment">## 集群名称</span></span><br><span class="line">        <span class="attr">namespace:</span>            <span class="comment">## 命名空间</span></span><br><span class="line">        <span class="attr">ephemeral:</span> <span class="literal">true</span>       <span class="comment">## 临时实例</span></span><br></pre></td></tr></table></figure>
<p>或者在启动加入<code>-Dspring.cloud.nacos.discovery.cluster-name=SH</code></p>
<h2 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h2><p>新版nacos已经包含ribbon<br>可以使用loadbalancer实现负载均衡</p>
<h2 id="配置中心"><a href="#配置中心" class="headerlink" title="配置中心"></a>配置中心</h2><p>添加依赖  </p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-config<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 对于高版本的springcloud，还需要这个，要不然无法读取bootstrap.yml文件 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-bootstrap<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>添加bootstrap.yml文件<br>配置  </p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">education-service</span></span><br><span class="line">  <span class="attr">profiles:</span></span><br><span class="line">    <span class="attr">active:</span> <span class="string">dev</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">server-addr:</span> <span class="string">localhost:8848</span></span><br><span class="line">      <span class="attr">config:</span></span><br><span class="line">        <span class="attr">file-extension:</span> <span class="string">yaml</span></span><br></pre></td></tr></table></figure>
<h2 id="实现热更新"><a href="#实现热更新" class="headerlink" title="实现热更新"></a>实现热更新</h2><p>使用<code>@ConfigurationProperties</code>的属性配置注解注入，自动刷新<br>通过<code>@Value</code>注解注入，结合<code>@RefreshScope</code>注解实现刷新  </p>
<h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><ol>
<li>不是所有的配置都适合放到配置中心，将一些关键参数，需要运行时要调整的参数放到nacos配置中心，一般都是自定义配置  </li>
</ol>
]]></content>
      <categories>
        <category>spring cloud</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>nacos</tag>
      </tags>
  </entry>
  <entry>
    <title>virtualbox安装Ubuntu显示不全</title>
    <url>/2023/05/06/virtualboxan-zhuang-ubuntuxian-shi-bu-quan/</url>
    <content><![CDATA[<p>页面显示不全，无法点击下一步</p>
<p>点击<strong>Alt+F7</strong>,鼠标晃动即可拖拽页面进行下一步。</p>
]]></content>
      <tags>
        <tag>VirtualBox</tag>
        <tag>Ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title>初识docker</title>
    <url>/2023/05/07/chu-shi-docker/</url>
    <content><![CDATA[<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>没啥可说的,按照官方文档安装即可</p>
<h2 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h2><p>通过<code>docker --help</code>了解命令</p>
<h3 id="镜像操作"><a href="#镜像操作" class="headerlink" title="镜像操作"></a>镜像操作</h3><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker save -o [保存的目标文件名称] [镜像名称]</span><br><span class="line">docker rmi [镜像名称]</span><br><span class="line">docker load -i [目标文件名称]</span><br></pre></td></tr></table></figure>
<h3 id="容器操作"><a href="#容器操作" class="headerlink" title="容器操作"></a>容器操作</h3><p>容器保护三个状态：</p>
<ul>
<li>运行：进程正常运行</li>
<li>暂停：进程暂停，CPU不再运行，并不释放内存</li>
<li>停止：进程终止，回收进程占用的内存、CPU等资源</li>
</ul>
<p>其中：</p>
<ul>
<li>docker run：创建并运行一个容器，处于运行状态</li>
<li>docker pause：让一个运行的容器暂停</li>
<li>docker unpause：让一个容器从暂停状态恢复运行</li>
<li>docker stop：停止一个运行的容器</li>
<li><p>docker start：让一个停止的容器再次运行</p>
</li>
<li><p>docker rm：删除一个容器</p>
</li>
</ul>
<p>进入容器</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker <span class="built_in">exec</span> -it mn bash</span><br></pre></td></tr></table></figure>
<p>命令解读：</p>
<ul>
<li>docker exec ：进入容器内部，执行一个命令</li>
<li>-it : 给当前进入的容器创建一个标准输入、输出终端，允许我们与容器交互</li>
<li>mn ：要进入的容器的名称</li>
<li>bash：进入容器后执行的命令，bash是一个linux终端交互命令</li>
</ul>
<h3 id="数据卷"><a href="#数据卷" class="headerlink" title="数据卷"></a>数据卷</h3><h4 id="数据卷操作的基本语法如下"><a href="#数据卷操作的基本语法如下" class="headerlink" title="数据卷操作的基本语法如下"></a>数据卷操作的基本语法如下</h4><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker volume [COMMAND]</span><br></pre></td></tr></table></figure>
<p><code>docker volume</code>命令是数据卷操作，根据命令后跟随的<code>command</code>来确定下一步的操作：</p>
<ul>
<li>create 创建一个volume</li>
<li>inspect 显示一个或多个volume的信息</li>
<li>ls 列出所有的volume</li>
<li>prune 删除未使用的volume</li>
<li>rm 删除一个或多个指定的volume</li>
</ul>
<h4 id="挂载数据卷"><a href="#挂载数据卷" class="headerlink" title="挂载数据卷"></a>挂载数据卷</h4><p>我们在创建容器时，可以通过 -v 参数来挂载一个数据卷到某个容器内目录，命令格式如下：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker run \</span><br><span class="line">  --name mn \</span><br><span class="line">  -v [数据卷名称或宿主机目录或宿主机文件:容器内目录或文件] \</span><br><span class="line">  -p 8080:80</span><br><span class="line">  ppp \</span><br></pre></td></tr></table></figure>
<p>这里的-v就是挂载数据卷的命令：</p>
<ul>
<li><code>-v html:/root/htm</code> ：把html数据卷挂载到容器内的/root/html这个目录中</li>
<li><code>-v /temp/mysql/config/:/etc/mysql/conf.d/</code> ：把html数据卷挂载到容器内的/root/html这个目录中</li>
<li><code>-v /temp/nginx/index.html:/etc/nginx/index.html</code> ：把html数据卷挂载到容器内的/root/html这个目录中</li>
</ul>
]]></content>
      <categories>
        <category>docker</category>
      </categories>
  </entry>
  <entry>
    <title>提高记忆力的方法</title>
    <url>/2023/05/20/ti-gao-ji-yi-li-de-fang-fa/</url>
    <content><![CDATA[<h2 id="首先，从身体层面上"><a href="#首先，从身体层面上" class="headerlink" title="首先，从身体层面上"></a>首先，从身体层面上</h2><h3 id="作息一定要规律"><a href="#作息一定要规律" class="headerlink" title="作息一定要规律"></a>作息一定要规律</h3><h3 id="饮食一定要均衡"><a href="#饮食一定要均衡" class="headerlink" title="饮食一定要均衡"></a>饮食一定要均衡</h3><h3 id="运动一定要达标"><a href="#运动一定要达标" class="headerlink" title="运动一定要达标"></a>运动一定要达标</h3><h2 id="其次，在方法上"><a href="#其次，在方法上" class="headerlink" title="其次，在方法上"></a>其次，在方法上</h2>]]></content>
      <categories>
        <category>随笔</category>
      </categories>
  </entry>
  <entry>
    <title>算法</title>
    <url>/2023/05/28/suan-fa-bi-ji/</url>
    <content><![CDATA[<h2 id="查找算法"><a href="#查找算法" class="headerlink" title="查找算法"></a>查找算法</h2><div class="table-container">
<table>
<thead>
<tr>
<th>查找算法</th>
<th>（平均）时间复杂度</th>
<th>空间复杂度</th>
<th>条件</th>
</tr>
</thead>
<tbody>
<tr>
<td>顺序查找</td>
<td><script type="math/tex">O(n)</script></td>
<td><script type="math/tex">O(1)</script></td>
<td></td>
</tr>
<tr>
<td>二分查找</td>
<td><script type="math/tex">O(log_2n)</script></td>
<td><script type="math/tex">O(1)</script></td>
<td>有序</td>
</tr>
<tr>
<td>插值查找</td>
<td><script type="math/tex">O(log_2(log_2n))</script></td>
<td><script type="math/tex">O(1)</script></td>
<td>有序</td>
</tr>
<tr>
<td>斐波拉契查找</td>
<td><script type="math/tex">O(log_2n)</script></td>
<td><script type="math/tex">O(n)</script></td>
<td>有序</td>
</tr>
<tr>
<td>分块查找</td>
<td><script type="math/tex">O(log_2n)\sim O(n)</script></td>
<td><script type="math/tex">O(1)\sim O(n)</script></td>
<td>块间有序</td>
</tr>
<tr>
<td>树表查找（BST）</td>
<td><script type="math/tex">O(log_2n)</script></td>
<td><script type="math/tex">O(1)</script></td>
<td></td>
</tr>
<tr>
<td>哈希查找</td>
<td><script type="math/tex">O(1)</script></td>
<td><script type="math/tex">O(n)</script></td>
</tr>
</tbody>
</table>
</div>
<h3 id="顺序查找"><a href="#顺序查找" class="headerlink" title="顺序查找"></a>顺序查找</h3><p>顺序查找也称为线形查找，属于<strong>无序</strong>查找算法。从数据结构线性表的一端开始，顺序扫描，依次将扫描到的结点关键字与给定值相比较，若相等则表示查找成功；若扫描结束仍没有找到关键字等于给定值的结点，表示查找失败。</p>
<h3 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h3><p>假设表中元素是按<strong>升序</strong>排列，将表中间位置记录的关键字与查找关键字比较，如果两者相等，则查找成功；否则利用中间位置记录将表分成前、后两个子表，如果中间位置记录的关键字大于查找关键字，则进一步查找前一子表，否则进一步查找后一子表。重复以上过程，直到找到满足条件的记录，使查找成功，或直到子表不存在为止，此时查找不成功。</p>
<p>注意，这里的前提条件是表中的元素是有序的，才能够使用二分查找算法。</p>
<h3 id="插值查找"><a href="#插值查找" class="headerlink" title="插值查找"></a>插值查找</h3><p>插值查找，有序表的一种查找方式。插值查找是根据查找关键字与查找表中最大最小记录关键字比较后的查找方法。插值查找基于二分查找，将查找点的选择改进为<strong>自适应选择</strong>，提高查找效率。</p>
<p>这里自适应选择是什么意思呢？举个栗子，如果现在有一个单词 <code>abandon</code> 你不认识，你想要在字典里查这个单词的意思，你会怎么做，你会先翻到书中间，然后一半一半地向前找吗？你肯定会会将书翻到比较靠前的位置，找到以 <code>a</code> 开头的位置，然后考察第二个字母，以此类推，直到查到这个单词。你将书翻到靠前的位置这个动作就是自适应，因为你知道 <code>abandon</code> 这个单词大概率在字典的前面（乱序字典不算）。</p>
<p>很显然，插值查找是二分查找的改进，同时又对二分查找做了进一步的限制，就是<strong>待查找的元素要分布均匀</strong>，根据待查找元素可能出现的位置的概率（期望）进行下一步的范围选择，这时插值查找的效率才会优于二分查找，具体的查找点选择方式如下：</p>
<p>二分查找中的 mid 索引：</p>
<script type="math/tex; mode=display">
mid=\frac {low+high}{2}=low+\frac 12(high-low)</script><p>插值查找中的 mid 索引：</p>
<script type="math/tex; mode=display">
mid=low+\frac{des-array[low]}{array[high]-array[low]}(high-low)</script><h3 id="斐波那契查找"><a href="#斐波那契查找" class="headerlink" title="斐波那契查找"></a>斐波那契查找</h3><p>  也是二分查找的一种提升算法，通过运用黄金比例的概念在数列中选择查找点进行查找，提高查找效率。同样地，斐波那契查找也属于一种有序查找算法。</p>
<p><img src="./20210528172236922.png" alt="20210528172236922"></p>
<p>  相对于折半查找，一般将待比较的key值与第mid=（low+high）/2位置的元素比较，比较结果分三种情况：</p>
<ol>
<li><p>相等，mid位置的元素即为所求</p>
</li>
<li><p>> ，low=mid+1</p>
</li>
<li><p>\&lt;，high=mid-1</p>
</li>
</ol>
<p>　　斐波那契查找与折半查找很相似，他是根据斐波那契序列的特点对有序表进行分割的。他要求开始表中记录的个数为某个斐波那契数，及n=F(k)-1;</p>
<p>  开始将k值与第F(k-1)位置的记录进行比较(及mid=low+F(k-1)-1),比较结果也分为三种</p>
<ol>
<li>相等，mid位置的元素即为所求</li>
<li><p>>，low=mid+1,k-=2</p>
</li>
<li><p>\&lt;，high=mid-1,k-=1</p>
<p>说明：low=mid+1说明待查找的元素在[mid+1,high]范围内，k-=2 说明范围[mid+1,high]内的元素个数为n-(F(k-1))= Fk-1-F(k-1)=Fk-F(k-1)-1=F(k-2)-1个，所以可以递归的应用斐波那契查找。</p>
</li>
</ol>
<h3 id="分块查找"><a href="#分块查找" class="headerlink" title="分块查找"></a>分块查找</h3><p>分块查找又称索引顺序查找，是对顺序查找的一种改进方法。在此查找方法中，除了表本身外，还需要建立一个<strong>索引表</strong>。对表进行分块，分成几个子表，将子表中的索引保存至索引表，索引表按关键字有序，则<strong>分块有序</strong>，即前一个子表中所有元素均小于后一个子表中所有元素（大于同理）。</p>
<p><img src="./20210528172312662.png" alt="20210528172312662"></p>
<p>因此，分块查找分为两步，第一步通过二分查找或顺序查找确定待查找元素所在的块，第二步，在块中进行顺序查找。</p>
<h3 id="树表查找"><a href="#树表查找" class="headerlink" title="树表查找"></a>树表查找</h3><h4 id="二叉排序树-BST"><a href="#二叉排序树-BST" class="headerlink" title="二叉排序树(BST)"></a>二叉排序树(BST)</h4><p>二叉排序树（Binary Sort Tree）或是一棵空树，或是具有下列性质的二叉树：</p>
<ol>
<li>若它的左子树不为空，则左子树上的所有结点的值均小于它的根结点的值；</li>
<li>若它的右子树不为空，则右子树上的所有结点的值均大于它的根结点的值；</li>
<li>它的左右子树也是二叉排序树。</li>
</ol>
<p><img src="./20210528172340191.png" alt="20210528172340191"></p>
<p>二叉排序树又称二叉查找树，它的查找过程如下，当二叉排序树不为空时，首先将给定值和根结点进行比较，若相等，则查找成功；若小于根结点，则在左子树上继续查找；若大于根结点，则在右子树上继续查找。</p>
<h4 id="平衡二叉排序树-BBT"><a href="#平衡二叉排序树-BBT" class="headerlink" title="平衡二叉排序树(BBT)"></a>平衡二叉排序树(BBT)</h4><p>平衡二叉树（Balanced Binary Tree）又称 AVL 树。它或是一棵空树，或是具有下列性质的二叉树：它的左右子树均是平衡二叉树，且<strong>左右子树的高度差的绝对值不超过1</strong>。</p>
<p>如果构造二叉排序树的同时保证它是平衡二叉树，那么这样的树称为<strong>平衡二叉排序树</strong>（BBST），可以证明它的深度是和 O ( l o g 2 n ) O(log_2n)O(log2n) 一个数量级的，那么在进行查找时的时间复杂度就可以固定在 O ( l o g 2 n ) O(log_2n)O(log2n) ，而不会出现二叉排序树中的最坏的情况。</p>
<p>下面是一棵平衡二叉排序树：</p>
<p><img src="./2021052817240771.png" alt="在这里插入图片描述"></p>
<p>平衡二叉排序树的查找过程和二叉排序树完全相同。</p>
<h4 id="B-树"><a href="#B-树" class="headerlink" title="B-树"></a>B-树</h4><p>B-树是一种平衡的多路（查找路径不止两条）查找树，它在文件系统中很有用。<br>一棵 m 阶的B-树，或为空树，或为满足下列特性的 m 叉树：</p>
<ol>
<li>树中每个结点至多有 m 棵子树；</li>
<li>若根结点不是叶子结点，则至少有两棵子树；</li>
<li>除根之外的所有非终端结点至少有 m/2 棵子树；</li>
<li>所有的非终端结点中包含下列信息数据</li>
</ol>
<script type="math/tex; mode=display">
(n,A_0,K_1,A_1,K_2,A_2,...,K_n,A_n)</script><p>其中<script type="math/tex">K_i</script>为关键字，且<script type="math/tex">K_i<K_{i+1}</script>；<script type="math/tex">Ai</script>为指向子树根节点的指针，且<script type="math/tex">K_{i+1}</script>所指向的子树中的所有结点关键字均小于<script type="math/tex">K_i</script>，<script type="math/tex">A_i</script>所指向的子树所有关键字均大于<script type="math/tex">K_i</script>。</p>
<ol>
<li>所有的叶子结点都出现在同一层次上，且不携带信息（可以看作 null）。</li>
</ol>
<p>特别地，3阶B-树又称为2-3树，下面是一棵4阶的B-树：</p>
<p><img src="./20210528172438734.png" alt="在这里插入图片描述"></p>
<p>B-树的查找和二叉排序树类似，首先从根结点开始，逐层往下顺指针查找结点，然后在结点的关键字中进行查找。</p>
<p>举个栗子，如果要查找关键字47，首先从根节点开始，因为47&gt;35，所以关键字若存在必在<script type="math/tex">A_1</script>所指的子树中，找到下一个结点，该节点有两个关键字，而43&lt;47&lt;78，所以关键字若存在必在<script type="math/tex">A_1</script>所指的子树中，找到下一个节点，该节点有3个关键字，顺序查找找到了关键字47。</p>
<p>由此可见，B-树的查找主要涉及两个操作：在树中找结点；在结点中找关键字。</p>
<h4 id="B-树-1"><a href="#B-树-1" class="headerlink" title="B+树"></a>B+树</h4><p>B+树是应文件系统所需而出的一种B-树的变型树。一棵 m 阶的B+树和 m 阶的B-树的差异在于：</p>
<ol>
<li>有 n 棵子树的结点中含有n个关键字；</li>
<li>所有的叶子结点中包含了全部关键字的信息，及指向含这些关键字记录的指针，且叶子结点本身依关键字的大小自小而大<strong>顺序链接</strong>。</li>
<li>所有的非终端结点可以看成是索引部分，结点中仅含有其子树（根结点）中的最大（或最小）关键字。</li>
</ol>
<p>下面是一棵3阶的B+树：</p>
<p><img src="./20210528172456282.png" alt="在这里插入图片描述"></p>
<p>概括来说就是相比于B-树，B+树的非叶子结点不包含关键字的全部信息，仅保存最值充当索引，所有的数据信息保存在叶子结点中，而且叶子结点按关键字大小顺序链接。</p>
<p>因此，对于B+树，有两种查找算法，一种是从根结点开始进行随机查找；一种是从最小关键字开始，顺着链表顺序查找。随机查找基本和B-树相同，不同之处是，每次比较关键值相等时，并不会停止，而是会继续向下直到叶子结点。</p>
<h4 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h4><p>红黑树是每个结点都带有颜色属性的二叉查找树，颜色或红色或黑色，相对于二叉查找树，红黑树增加了以下额外要求:</p>
<ol>
<li>结点是红色或黑色；</li>
<li>根结点是黑色；</li>
<li>所有叶子都是黑色；</li>
<li>每个红色结点的两个子结点都是黑色（从每个叶子到根的所有路径上不能有两个连续的红色结点）；</li>
<li>从任一节结点其每个叶子的所有路径都包含相同数目的黑色结点。</li>
</ol>
<p>通过对任何一条从根到叶子简单路径上的颜色来约束，红黑树保证最长路径不超过最短路径的两倍，因而近似于平衡。</p>
<p>下面是一棵红黑树：</p>
<p><img src="./20210528172519466.png" alt="在这里插入图片描述"></p>
<p>红黑树的基本思想是用标准的二叉查找树（完全由2-结点构成）和一些额外的信息（替换3-结点）来表示2-3树。</p>
<h3 id="哈希查找"><a href="#哈希查找" class="headerlink" title="哈希查找"></a>哈希查找</h3><p>上面介绍的查找方法都是建立在”比较“的基础上进行的，通过有限次数的比较，不断缩小范围，直至查找完成。很显然，这种算法的效率依赖于查找过程中比较的次数。</p>
<p>那与没有一种方法可以不经过比较就得到待查找的记录呢？不难想到如果想要实现这种想法，就需要将关键字映射到一个唯一确定的位置，每次查找时只需要获取这个位置即可，问题就是如何确定这个映射关系。</p>
<p>这个映射关系称为<strong>哈希（Hash）函数</strong>或散列函数，按照这个函数映射出的表称为<strong>哈希表</strong>（Hash Table）或者散列表。</p>
<p>构造哈希函数的方法有很多，一个好的哈希函数因该尽可能地减少冲突，尽可能地将关键字均匀的映射到哈希表中。</p>
<p>常用的构造哈希函数地方法有：</p>
<ol>
<li>直接地址法：取关键字或关键字的某个线性函数值为散列地址。</li>
<li>数字分析法：假设关键字是以 r 为基的数，并且哈希表中可能出现的关键字都是事先知道的，则可取关键字的若干数位组成哈希地址。</li>
<li>平方取中法：取关键字平方后的中间几位为哈希地址。</li>
<li>折叠法：将关键字分割成位数相同的几部分（最后一部分的位数可以不同），然后取这几部分的叠加和（舍去进位）作为哈希地址。</li>
<li>除留取余法：取关键字被某个不大于散列表表长m的数p除后所得的余数为哈希地址。</li>
<li>随机数法：选则一个随机函数，取关键字的随机函数值为它的哈希地址。</li>
</ol>
<p>常用的处理冲突的方法有：</p>
<ol>
<li>开放地址法</li>
<li>再哈希法</li>
<li>链地址法</li>
<li>建立公共溢出区</li>
</ol>
<p>哈希查找的操作步骤：</p>
<ol>
<li>用给定的哈希函数构造哈希表；</li>
<li>根据选择的冲突处理方法解决地址冲突；</li>
<li>在哈希表的基础上执行哈希查找。</li>
</ol>
<p>在哈希查找的过程中，只需先将要查找的数据映射为它的哈希值，然后查找具有这个哈希值的数据，这就大大减少了查找次数。如果构造哈希函数的参数经过精心设计，内存空间也足以存放哈希表，查找一个数据元素所需的比较次数基本上就接近于一次。</p>
<h2 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h2><div class="table-container">
<table>
<thead>
<tr>
<th>排序算法</th>
<th>平均时间复杂度</th>
<th>空间复杂度</th>
<th>稳定性</th>
</tr>
</thead>
<tbody>
<tr>
<td>冒泡排序</td>
<td><script type="math/tex">O(n^2)</script></td>
<td><script type="math/tex">O(1)</script></td>
<td>稳定</td>
</tr>
<tr>
<td>选择排序</td>
<td><script type="math/tex">O(n^2)</script></td>
<td><script type="math/tex">O(1)</script></td>
<td>不稳定</td>
</tr>
<tr>
<td>插入排序</td>
<td><script type="math/tex">O(n^2)</script></td>
<td><script type="math/tex">O(1)</script></td>
<td>稳定</td>
</tr>
<tr>
<td>希尔排序</td>
<td><script type="math/tex">O(n^\frac32)</script></td>
<td><script type="math/tex">O(1)</script></td>
<td>不稳定</td>
</tr>
<tr>
<td>归并排序</td>
<td><script type="math/tex">O(n*log_2n)</script></td>
<td><script type="math/tex">O(n)</script></td>
<td>稳定</td>
</tr>
<tr>
<td>快速排序</td>
<td><script type="math/tex">O(n*log_2n)</script></td>
<td><script type="math/tex">O(log_2n)</script></td>
<td>不稳定</td>
</tr>
<tr>
<td>堆排序</td>
<td><script type="math/tex">O(n*log_2n)</script></td>
<td><script type="math/tex">O(1)</script></td>
<td>不稳定</td>
</tr>
<tr>
<td>计数排序</td>
<td><script type="math/tex">O(n+k)</script></td>
<td><script type="math/tex">O(k)</script></td>
<td>稳定</td>
</tr>
<tr>
<td>桶排序</td>
<td><script type="math/tex">O(n+c)</script></td>
<td><script type="math/tex">O(n+m)</script></td>
<td>稳定</td>
</tr>
<tr>
<td>基数排序</td>
<td><script type="math/tex">O(n(n+r))</script></td>
<td><script type="math/tex">O(r*d)</script></td>
<td>稳定</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li><p>n 个记录个数</p>
</li>
<li><p>d 个关键字</p>
</li>
<li><p>r 为关键码的取值范围</p>
</li>
</ul>
<h3 id="交换排序"><a href="#交换排序" class="headerlink" title="交换排序"></a>交换排序</h3><h4 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h4><p>将相邻关键字进行比较，较大的下沉，较小的上浮（假设要求升序排列，后算的算法相同），一趟过后最大的关键字会到末尾，借着按照同样的方式进行第二轮比较，次大的关键字会到倒数第二位，以此类推。</p>
<p>在排序的过程中，较小的关键字形如水里的泡泡一样，逐渐向上漂浮，而较大的关键字像石头一样不断下沉，因此这种算法被形象地称为<strong>冒泡</strong>排序。</p>
<p><img src="./20210531162206639.gif" alt="在这里插入图片描述"></p>
<h4 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h4><p>快速排序是对冒泡排序的一种改进，它同样采用了分治的策略，算法思想如下：</p>
<ol>
<li>先从数列中取出一个数作为基准数（pivot）。</li>
<li>分区过程，将比这个数大的数全放到它的右边，小于或等于它的数全放到它的左边。</li>
<li>再对左右区间重复第二步，直到各区间只有一个数。</li>
</ol>
<p>快速排序的难点在于如何将基准数放在正确的位置上，常见方法有两种：挖坑法和指针交换法，两种方法的原理几乎相同，只是代码层面有一点不同，挖坑法的具体演示如下图。</p>
<p><img src="./20210531162330817.gif" alt="在这里插入图片描述"></p>
<h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><h4 id="简单的选择排序"><a href="#简单的选择排序" class="headerlink" title="简单的选择排序"></a>简单的选择排序</h4><p>每一趟在 n-i+1 (i=1,2,…,n-1) 个记录中选取关键字最小的元素作为有序序列的第 i 个元素，重复 n-1 趟。</p>
<p><img src="./20210531162229367.gif" alt="在这里插入图片描述"></p>
<h4 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h4><p>堆排序是利用<strong>堆</strong>这种数据结构所设计的一种排序算法。堆是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。</p>
<p><img src="./20210531162346782.gif" alt="在这里插入图片描述"></p>
<h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><h4 id="简单插入排序"><a href="#简单插入排序" class="headerlink" title="简单插入排序"></a>简单插入排序</h4><p>在要排序的一组数中，假定前 n-1 个数已经排好序，现在将第 n 个数插到前面的有序数列中，使得这 n 个数也是排好顺序的。如此反复循环，直到全部排好顺序。</p>
<p><img src="./2021053116224238.gif" alt="在这里插入图片描述"></p>
<h4 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h4><p>希尔排序又称“<strong>缩小增量排序</strong>”，它也是一种属于插入排序类的方法。</p>
<p>从对直接插入排序的分析来看，如果序列基本有序，那么元素移动的次数就会大大减少，当 n 值很小时，直接插入排序的效率也会非常高，基于此，希尔排序对直接插入排序进行了改进，其基本思想如下：</p>
<p>在要排序的一组数中，根据某一增量分为若干子序列，并对子序列分别进行插入排序。然后逐渐将增量减小，并重复上述过程。直至增量为1，此时数据序列基本有序，最后进行插入排序。</p>
<p><img src="./20210531162255673.gif" alt="在这里插入图片描述"></p>
<h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><p>归并排序是建立在归并操作上的一种有效，稳定的排序算法，该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。</p>
<p>分治法中的“分”和“治”是两个过程，“分”是不断地将序列分成从中间两段，直至最后子序列只有一个元素；“治”是将一个个的子序列进行排序得到有序的子序列，再将子序列合并得到完全有序的序列，即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为<strong>二路归并</strong>。</p>
<p><img src="./20210531162309580.gif" alt="在这里插入图片描述"></p>
<h3 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h3><p>计数排序不是一个基于比较的排序算法。</p>
<p>计数排序的基本思想是对于给定的输入序列中的每一个元素 x，确定该序列中值小于 x 的元素的个数（此处并非比较各元素的大小，而是通过对元素值的计数和计数值的累加来确定）。一旦获得该信息，就可以将 x 直接存放到最终的输出序列的正确位置上。例如有 10 个年龄不同的人，统计出有 8 个人的年龄比 A 小，那 A 的年龄就排在第 9 位。</p>
<p>计数排序的核心在于将输入的数据值转化为键存储在额外开辟的数组空间中。作为一种线性时间复杂度的排序，计数排序要求输入的数据必须是有确定范围的整数。</p>
<p><img src="./2021053116240161.gif" alt="在这里插入图片描述"></p>
<h3 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a>桶排序</h3><p>桶排序是计数排序的升级版，它的基本思想是将数组分到有限数量的桶里，每个桶再进行排序（可以使用别的排序算法或是以递归方式继续使用桶排序）。</p>
<p>将数组分配到有限数量的桶里需要一个高效的分配方法，尽可能地做到：</p>
<ol>
<li>在额外空间充足的情况下，尽量增大桶的数量</li>
<li>将输入的 N 个数据均匀的分配到 K 个桶中</li>
</ol>
<p>对于桶中元素的排序，选择何种比较排序算法对于性能的影响同样重要。</p>
<p><img src="./20210531162412130.gif" alt="在这里插入图片描述"></p>
<h3 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h3><p>基数排序是一种基于多关键字排序的的方法，什么是<strong>多关键字</strong>？举个栗子：</p>
<p>一副扑克牌（除去大小王），每张牌的位置由两个因素决定，一个是花色，一个是面值。同花色时面值小的在上，面值大的在下；不同花色，无论面值多少，先后顺序总是红桃♥、方片♦、梅花♣和黑桃♠ 。这里花色和面值就是多关键字。</p>
<p>现在这副牌已经洗乱了，现在你想给它排好序，就像刚买的时候一样，这个时候你会怎么做？你有两种做法：</p>
<ol>
<li>按照花色分成四份，每份按照面值排序，最后将四分排序好的牌按花色排序即可；</li>
<li>按照面值分成13份，每份按照花色排序，然后按照面值顺序取13张牌，直至所有花色取完即可。</li>
</ol>
<p>这里两种方式对应着基数排序的两种方法，第一种是<strong>最高位优先</strong>（Most Significant Digit first）法，简称 MSD 法；第二种是<strong>最低位优先</strong>（Least Significant Digit first）法，简称 LSD 法。</p>
<p>MSD 法：先按最高位关键字排序分组，同一组中记录，关键字相等，再对各组按次高位关键字排序分成子组，之后，对后面的关键字继续这样的排序分组，直到按最低位关键字对各子组排序后。再将各组连接起来，便得到一个有序序列。</p>
<p>LSD 法：先从最低位关键字开始排序，再对高一位关键字进行排序，依次重复，直到对第一个关键字排序后便得到一个有序序列。</p>
<p><img src="./20210531162428752.gif" alt="在这里插入图片描述"></p>
<h2 id="图算法"><a href="#图算法" class="headerlink" title="图算法"></a>图算法</h2><h3 id="路径查找算法"><a href="#路径查找算法" class="headerlink" title="路径查找算法"></a>路径查找算法</h3><h4 id="广度优先搜索算法"><a href="#广度优先搜索算法" class="headerlink" title="广度优先搜索算法"></a>广度优先搜索算法</h4><h4 id="深度优先搜索算法"><a href="#深度优先搜索算法" class="headerlink" title="深度优先搜索算法"></a>深度优先搜索算法</h4><h4 id="最短路径算法"><a href="#最短路径算法" class="headerlink" title="最短路径算法"></a>最短路径算法</h4><h4 id="所有点对最短路径算法"><a href="#所有点对最短路径算法" class="headerlink" title="所有点对最短路径算法"></a>所有点对最短路径算法</h4><h4 id="单源最短路径算法"><a href="#单源最短路径算法" class="headerlink" title="单源最短路径算法"></a>单源最短路径算法</h4><h4 id="最小生成树算法"><a href="#最小生成树算法" class="headerlink" title="最小生成树算法"></a>最小生成树算法</h4><h4 id="随机游走算法"><a href="#随机游走算法" class="headerlink" title="随机游走算法"></a>随机游走算法</h4><h3 id="中心性算法"><a href="#中心性算法" class="headerlink" title="中心性算法"></a>中心性算法</h3><h4 id="度中心性算法"><a href="#度中心性算法" class="headerlink" title="度中心性算法"></a>度中心性算法</h4><h4 id="接近中心性算法"><a href="#接近中心性算法" class="headerlink" title="接近中心性算法"></a>接近中心性算法</h4><h4 id="中间中心性算法"><a href="#中间中心性算法" class="headerlink" title="中间中心性算法"></a>中间中心性算法</h4><h4 id="PageRank算法"><a href="#PageRank算法" class="headerlink" title="PageRank算法"></a>PageRank算法</h4><h3 id="社团发现算法"><a href="#社团发现算法" class="headerlink" title="社团发现算法"></a>社团发现算法</h3><h4 id="度量算法（面向整体关系稠密度，用于衡量图的结构特性）"><a href="#度量算法（面向整体关系稠密度，用于衡量图的结构特性）" class="headerlink" title="度量算法（面向整体关系稠密度，用于衡量图的结构特性）"></a>度量算法（面向整体关系稠密度，用于衡量图的结构特性）</h4><h4 id="分量算法（用于发现连通簇）"><a href="#分量算法（用于发现连通簇）" class="headerlink" title="分量算法（用于发现连通簇）"></a>分量算法（用于发现连通簇）</h4><h4 id="标签传播算法（可基于节点标签快速推断群组）"><a href="#标签传播算法（可基于节点标签快速推断群组）" class="headerlink" title="标签传播算法（可基于节点标签快速推断群组）"></a>标签传播算法（可基于节点标签快速推断群组）</h4><h4 id="Louvain模块度算法（用于研究分组的"><a href="#Louvain模块度算法（用于研究分组的" class="headerlink" title="Louvain模块度算法（用于研究分组的"></a>Louvain模块度算法（用于研究分组的</h4>]]></content>
  </entry>
  <entry>
    <title>GithubAction的自动化构建</title>
    <url>/2023/05/11/zi-dong-hua-gou-jian/</url>
    <content><![CDATA[<p>在项目创建<code>.github/workflows</code>文件夹<br>创建main.yml文件,名字随意<br>文件要包含几个主要信息</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="string">//</span> <span class="string">如不设置,这个流程名为文件名</span></span><br><span class="line"><span class="attr">name:</span></span><br><span class="line"><span class="string">//</span> <span class="string">这个流程的主要信息,监听事件</span>  </span><br><span class="line"><span class="attr">on:</span></span><br><span class="line"><span class="string">//</span> <span class="string">包含的任务,并且任务之间可以有依赖关系</span>  </span><br><span class="line"><span class="attr">jobs:</span></span><br></pre></td></tr></table></figure>
<p>任务和任务之间是并发的  </p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="string">//</span> <span class="string">任务的名字,也可以用name设置</span></span><br><span class="line"><span class="attr">job:</span></span><br><span class="line">  <span class="string">//</span> <span class="string">任务的执行环境</span></span><br><span class="line">  <span class="attr">runs-on:</span> <span class="string">ubuntu-22.04</span></span><br><span class="line">  <span class="string">//</span> <span class="string">这个任务的具体步骤,这是顺序执行的</span></span><br><span class="line">  <span class="attr">steps:</span></span><br></pre></td></tr></table></figure>
<p>至于<code>seteps</code>的信息  </p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">steps:</span></span><br><span class="line">    <span class="string">//</span> <span class="string">步骤的具体名称</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">deloy</span></span><br><span class="line">    <span class="string">//</span> <span class="string">使用的包,可以查看github的Action市场,它提供了许多工具</span></span><br><span class="line">    <span class="attr">uses:</span> <span class="string">srueda99/scp-action@v12</span></span><br><span class="line">    <span class="string">//</span> <span class="string">参数,当钱包的参数</span></span><br><span class="line">    <span class="attr">with:</span></span><br><span class="line">      <span class="attr">port:</span> <span class="number">22</span></span><br><span class="line">      <span class="attr">host:</span> <span class="number">1.1</span><span class="number">.1</span><span class="number">.1</span></span><br><span class="line">      <span class="attr">username:</span> <span class="string">root</span></span><br></pre></td></tr></table></figure>
<p>列几个常用的包:</p>
<ul>
<li>actions/checkout  拉取仓库进行处理</li>
<li>actions/setup-node  安装node依赖</li>
<li>actions/setup-java  安装java依赖</li>
<li>appleboy/ssh-action  远程连接服务器,执行命令</li>
<li>appleboy/scp-action  传输文件,如将打包好的包传输给服务器</li>
</ul>
]]></content>
      <tags>
        <tag>GithubAction</tag>
      </tags>
  </entry>
  <entry>
    <title>麻绳专挑细处断,噩运只找苦命人</title>
    <url>/2023/04/28/ma-sheng-zhuan-tiao-xi-chu-duan-e-yun-zhi-zhao-ku-ming-ren/</url>
    <content><![CDATA[<p>不是说之专挑细处，只是因为麻绳的粗细不同，同样的力道麻绳粗的一段便不会断<br>就厄运而言，实力强大的人他的容错更高<br>因此，我们能做的只有时刻提升自己，以应对可能出现的情况</p>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
  </entry>
</search>
